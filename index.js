
var bodyParser = require('body-parser');
var jwt = require('jsonwebtoken');
const config = require('config');
var randtoken = require('rand-token');
const authMiddleware = require('./middlewares/Auth_middleware');
//-------------------
var passport = require('passport')
var JwtStrategy = require('passport-jwt').Strategy
var ExtractJwt = require('passport-jwt').ExtractJwt
//-------------------
const express = require('express');
const app = express();





const PORT = process.env.PORT || 4000;
const NODE_ENV = process.env.NODE_ENV || 'development';



//================  Middlewares  ============================//
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true }))
//------------
app.use(passport.initialize())
app.use(passport.session())
passport.serializeUser(function (user, done) {
    done(null, user.username)
  })
  
  /*
  passport.deserializeUser(function (username, done) {
    done(null, username)
  })
  */


 var opts = {}

 // Setup JWT options
 opts.jwtFromRequest = ExtractJwt.fromAuthHeaderWithScheme("jwt")
 opts.secretOrKey = config.get('SECRET')
 //The variable jwtPayload will have the user object that we encrypt in the userâ€™s login:
 passport.use(new JwtStrategy(opts, function (jwtPayload, done) {
   //If the token has expiration, raise unauthorized
   var expirationDate = new Date(jwtPayload.exp * 1000)
   if(expirationDate < new Date()) {
     return done(null, false);
   }
   var user = jwtPayload
   done(null, user)
 }))




var refreshTokens = {}
var SECRET = config.get('SECRET');
//console.log(SECRET);

app.post('/login', function (req, res, next) {
    var username = req.body.username
    var password = req.body.password
    var user = {
        'username': username,
        'role': 'admin'
    }

    var token = jwt.sign(user, SECRET, { expiresIn: 300 }); // expire in 5 minutes
    var refreshToken = randtoken.uid(256);
    refreshTokens[refreshToken] = username;

    res.json({ token: 'JWT ' + token, refreshToken: refreshToken })
});



// To request a new access token we have created the /token resource
app.get('/token', (req, res) => {
    const username = req.body.username;
    const refreshToken = req.body.refreshToken;

    if ((refreshToken in refreshTokens) && (refreshTokens[refreshToken] === username)) {

        var user = {
            'username': username,
            'role': 'admin'
        }
        var token = jwt.sign(user, SECRET, { expiresIn: 300 })
        res.json({ token: 'JWT ' + token })
    }
    else {
        res.sendStatus(401);
    }
});


// In an application in which a user can be working from different devices, 
// with a single identity (same username) but with different tokens on each device, 
// if one of these is lost or stolen, this method would allow the administrator to delete or disable
// the refresh token in question without the user being left without service on the other devices. 

//  In this case we simply deleted it from our list in memory. 
// In a complete implementation it would be necessary to verify that 
//the user who makes the request is an administrator or has the permissions for this resource.
app.post('/token/reject', function (req, res, next) {
    var refreshToken = req.body.refreshToken
    if (refreshToken in refreshTokens) {
        delete refreshTokens[refreshToken]
    }
    res.send(204)
})




// expose a resource that can only be accessed by sending a header with a previously obtained JWT token, 
// which will have been generated by our application and signed with our key (SECRET)
app.get('/test_jwt', authMiddleware, function (req, res) {    
    res.json({ success: 'You are authenticated with JWT!', user: req.user })
});


app.get('/test_jwt_by_passport', passport.authenticate('jwt'), (req, res) => {
    res.json({ success: 'You are authenticated with JWT!', user: req.user })
})




const server5 = app.listen(PORT, () => {
    let host = server5.address().address;
    let port = server5.address().port;
    //console.log(`API runnig on PORT: ${PORT}`)
    console.log('App listening at http://%s:%s', host, port);
});